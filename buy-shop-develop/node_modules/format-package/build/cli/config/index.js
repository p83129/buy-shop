"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.search = exports.searchPlaces = exports.loadConfig = exports.loadJson5 = exports.resolveModuleOrPath = exports.configModuleName = exports.configValidate = exports.configDefault = void 0;
const path_1 = require("path");
const fs = require("fs-extra");
const cosmiconfig = require("cosmiconfig");
const Joi = require("@hapi/joi");
const errors_1 = require("@hapi/joi/lib/errors");
const resolveFrom = require("resolve-from");
const JSON5 = require("json5");
const lib_1 = require("../../lib");
const schema_1 = require("./schema");
exports.configDefault = {
    config: lib_1.defaults,
    filepath: require.resolve('../../lib/defaults'),
    isDefault: true,
};
exports.configValidate = (config) => {
    const result = Joi.validate(config, schema_1.default);
    if (result.error) {
        return result;
    }
    if (!Array.isArray(config.order)) {
        return {
            error: new errors_1.ValidationError('Empty order property.'),
        };
    }
    return result;
};
exports.configModuleName = 'format-package';
exports.resolveModuleOrPath = ({ configPath, searchFrom, }) => {
    if (typeof configPath !== 'string') {
        return undefined;
    }
    let resolvedPath;
    // resolve as a node_modules, if undefined default to path.resolve if exists
    if (searchFrom) {
        resolvedPath = resolveFrom.silent(searchFrom, configPath);
    }
    if (!resolvedPath) {
        resolvedPath = path_1.resolve(configPath);
        resolvedPath = fs.existsSync(resolvedPath) ? resolvedPath : undefined;
    }
    return resolvedPath;
};
exports.loadJson5 = (filepath) => {
    try {
        const buf = fs.readFileSync(filepath, { encoding: 'utf8' });
        return JSON5.parse(buf);
    }
    catch (err) {
        err.message = `JSON Error in ${filepath}:\n${err.message}`;
        throw err;
    }
};
const createCosmiconfigLoader = () => ({
    '.json': { sync: exports.loadJson5 },
});
exports.loadConfig = (configPath) => __awaiter(void 0, void 0, void 0, function* () {
    const explorer = cosmiconfig(exports.configModuleName, {
        loaders: createCosmiconfigLoader(),
    });
    return explorer.load(configPath);
});
exports.searchPlaces = ({ moduleName, }) => {
    const places = [];
    if (moduleName) {
        places.push(`${moduleName}.js`, `${moduleName}.yaml`, `${moduleName}.yml`, `${moduleName}.json`, `${moduleName}.config.js`, `${moduleName}.config.yaml`, `${moduleName}.config.yml`);
    }
    places.push('package.json');
    return places;
};
const searchWithConfigPath = ({ configPath, searchFrom, }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Find the path by looking for a dependency or a local file
        // then load and validate the configuration
        const resolvedPath = exports.resolveModuleOrPath({ configPath, searchFrom });
        // Load and validate the configuration file contents
        const result = yield exports.loadConfig(resolvedPath);
        const { error } = exports.configValidate(result && result.config);
        // NOTE: This validation error handling is more strict than when a config
        //       path is not provided, as the intention is clearly expressed
        if (error) {
            throw error;
        }
        // Response must always include an error key (even if undefined)
        return Object.assign(Object.assign({}, result), { error });
    }
    catch (error) {
        // If something went wrong, gracefully fallback
        // to default config and report the error
        return Object.assign(Object.assign({}, exports.configDefault), { error });
    }
});
const searchWithoutConfigPath = ({ searchFrom, }) => __awaiter(void 0, void 0, void 0, function* () {
    // Configure the explorer with pre-defined properties above
    const explorer = cosmiconfig(exports.configModuleName, {
        packageProp: exports.configModuleName,
        searchPlaces: exports.searchPlaces({ moduleName: exports.configModuleName }),
        loaders: createCosmiconfigLoader(),
    });
    let error;
    try {
        // Search for the configuration based on config
        const result = yield explorer.search(searchFrom);
        // If configuration is found, validate it and
        // include error in the response
        if (result) {
            ({ error } = exports.configValidate(result.config));
            return Object.assign(Object.assign({}, result), { error });
        }
    }
    catch (e) {
        error = e;
    }
    // No configuration was found, so use default
    // and include any error that occured
    return Object.assign(Object.assign({}, exports.configDefault), { error });
});
exports.search = ({ configPath, searchFrom = process.cwd(), } = { searchFrom: process.cwd() }) => __awaiter(void 0, void 0, void 0, function* () {
    // Configuration loading is dependent on whether the
    // config path is given or if it has to be found
    return configPath
        ? searchWithConfigPath({ configPath, searchFrom })
        : searchWithoutConfigPath({ searchFrom });
});
//# sourceMappingURL=index.js.map